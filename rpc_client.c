/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "rpc.h"
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>


void
service_1(char *host,int newsockfd)
{
	CLIENT *clnt;
	int  *result_1;
	struct data  product_1_arg;
	struct d_ret  *result_2;
	struct data  average_1_arg;
	struct var_array  *result_3;
	struct data  prod2_1_arg;
	int x[5];
    int y[5];
    int i;
    double r;
    int ch;

    recv(newsockfd, x, 5*sizeof(int), 0);
    recv(newsockfd, y, 5*sizeof(int), 0);
    recv(newsockfd, &r, 1*sizeof(double), 0);
    recv(newsockfd, &ch, 1*sizeof(int), 0);
    #ifndef    DEBUG
                clnt = clnt_create (host, Service, Srv_1, "udp");
                if (clnt == NULL) 
                {
                    printf("Error on creating rpc server communication handler.\n");
                    clnt_pcreateerror (host);
                    exit (1);
                }
#endif    /* DEBUG */
    switch (ch) {
                case 1:

                
                product_1_arg.x.x_val = (int *) malloc (5 * sizeof(int));
        
        
                product_1_arg.y.y_val = (int *) malloc (5 * sizeof(int));
                
                for (i = 0; i < 5; i++)
                {
                    product_1_arg.x.x_val[i] = x[i];
                    product_1_arg.y.y_val[i] = y[i];
                }
                product_1_arg.a = r;
                result_1 = product_1(&product_1_arg, clnt);
                if (result_1 == (int *) NULL) {
            clnt_perror(clnt, "call failed");
        	}
                printf("Sending the results to socketclient\n");
                send(newsockfd, &result_1, sizeof(int), 0);

    }
    #ifndef    DEBUG
                clnt_destroy (clnt);
#endif     /* DEBUG */
/*	result_2 = average_1(&average_1_arg, clnt);
	if (result_2 == (struct d_ret *) NULL) {
		clnt_perror (clnt, "call failed");
	}
	result_3 = prod2_1(&prod2_1_arg, clnt);
	if (result_3 == (struct var_array *) NULL) {
		clnt_perror (clnt, "call failed");
	}*/
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


int
main (int argc, char *argv[])
{
	int sockfd, newsockfd, portno, clilen, n, done,i;
     char str[100];
     struct sockaddr_in serv_addr, cli_addr;
     int x[5];
    int y[5];
    double r;
    int ch;
    data product_1_arg;
    CLIENT *clnt;

     if (argc < 2) {
         fprintf(stderr,"ERROR, no port provided\n");
         exit(1);
     }

     sockfd = socket(AF_INET, SOCK_STREAM, 0); 
     if (sockfd < 0) 
         perror("ERROR opening socket");

     bzero((char *) &serv_addr, sizeof(serv_addr));

     portno = atoi(argv[1]);

     serv_addr.sin_family = AF_INET;

     serv_addr.sin_port = htons(portno);

     serv_addr.sin_addr.s_addr = INADDR_ANY;

     if (bind(sockfd, (struct sockaddr *) &serv_addr,
              sizeof(serv_addr)) < 0)
                  perror("ERROR on binding");

     listen(sockfd,5);

   for (;;)  {
     printf("Waiting for a connection...\n");
     clilen = sizeof(cli_addr);
     newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);
     if (newsockfd < 0) 
          perror("ERROR on accept");

            if (fork() == 0)  { 
                close (sockfd); 
                printf("Connected.\n");
                
           
            service_1(argv[2],newsockfd);

            	close(newsockfd);
                exit (0) ; 
             }
     
  }
}